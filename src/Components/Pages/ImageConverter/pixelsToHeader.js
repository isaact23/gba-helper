import Palette from "./palette";
let fileSaver = require("file-saver");

// TODO: Clean this code up for real; add way to convert multiple files at once
/**
 * Given an array of the RGB values of an image and a conversion mode,
 * generate a header file formatted for GBA.
 */
export function convert(pixels, mode, filename) {
    let dimensions = pixels.shape.slice();

    try {
        // Store output text
        let text = "// Generated by gbahelper.com\n";

        // Perform mode-dependent conversion
        if (mode === "bitmapRaw") {
            text += "// Conversion mode: Bitmap without Palette (32,768 colors)\n\n";
            text += "#include <stdint.h>\n\n"
            text += "#define " + filename + "_width " + dimensions[0] + "\n";
            text += "#define " + filename + "_height " + dimensions[1] + "\n\n";
            text += "const uint16_t " + filename + "_data [] = {\n";

            // Iterate through all pixels, left to right, then top to bottom
            for (let y = 0; y < dimensions[1]; y++) {
                text += "\t";
                for (let x = 0; x < dimensions[0]; x++) {
                    // Convert RGB to GBA-formatted hex
                    let r = pixels.get(x, y, 0);
                    let g = pixels.get(x, y, 1);
                    let b = pixels.get(x, y, 2);
                    let color = rgbToGba(r, g, b);
                    let hex = "0x" + color.toString(16).padStart(4, "0");
                    text += hex + ", ";
                }
                text += "\n";
            }
            text += "};\n";

        } else if (mode === "bitmapPalette") {
            // Create palette to store colors
            let palette = new Palette();

            text += "// Conversion mode: Bitmap with Palette (256 colors)\n\n";
            text += "#include <stdint.h>\n\n"
            text += "#define " + filename + "_width " + dimensions[0] + "\n";
            text += "#define " + filename + "_height " + dimensions[1] + "\n\n";
            text += "const uint8_t " + filename + "_data [] = {\n";

            // Iterate through all pixels, left to right, then top to bottom
            for (let y = 0; y < dimensions[1]; y++) {
                text += "\t";
                for (let x = 0; x < dimensions[0]; x++) {
                    // Convert RGB to GBA-formatted hex
                    let r = pixels.get(x, y, 0);
                    let g = pixels.get(x, y, 1);
                    let b = pixels.get(x, y, 2);
                    let color = rgbToGba(r, g, b);
                    // Add color to palette
                    let index = palette.addColor(color);
                    if (index == null) {
                        window.alert("Error during conversion: Color palette exceeds 256 colors - try reducing color" +
                            "count and submit again.");
                        return;
                    }
                    let hex = "0x" + index.toString(16).padStart(2, "0");
                    text += hex + ", ";
                }
                text += "\n";
            }
            text += "};\n\n";

            // Add palette here
            text += palette.getText();

        } else if (mode === "tile") {
            // Create palette to store colors
            let palette = new Palette();

            // Determine number of 8x8 tiles across/down
            let tileCountX = Math.ceil(dimensions[0] / 8);
            let tileCountY = Math.ceil(dimensions[1] / 8);

            text += "// Conversion mode: Tiles (8x8 squares, 256-color palette)\n\n";
            text += "#include <stdint.h>\n\n"
            text += "#define " + filename + "_tileCountX " + tileCountX + "\n";
            text += "#define " + filename + "_tileCountY " + tileCountY + "\n\n";
            text += "const uint8_t " + filename + "_data [] = {\n";

            // Iterate through tiles
            for (let tileY = 0; tileY < tileCountY; tileY++) {
                for (let tileX = 0; tileX < tileCountX; tileX++) {
                    // Iterate through pixels within each tile
                    for (let localY = 0; localY < 8; localY++) {
                        if (localY % 2 === 0) {
                            text += "\t";
                        }
                        let y = (tileY * 8) + localY;
                        for (let localX = 0; localX < 8; localX++) {
                            let x = (tileX * 8) + localX;
                            // If out of bounds, use first color in palette.
                            if (x >= dimensions[0] || y >= dimensions[1]) {
                                text += "0x00, ";
                            } else {
                                // Convert RGB to GBA-formatted hex
                                let r = pixels.get(x, y, 0);
                                let g = pixels.get(x, y, 1);
                                let b = pixels.get(x, y, 2);
                                let color = rgbToGba(r, g, b);
                                // Add color to palette
                                let index = palette.addColor(color);
                                if (index == null) {
                                    window.alert("Error during conversion: Color palette exceeds 256 colors - try reducing" +
                                        "color count and submit again.");
                                    return;
                                }
                                let hex = "0x" + index.toString(16).padStart(2, "0");
                                text += hex + ", ";
                            }
                        }
                        // Add line breaks every 16 entries
                        if (localY % 2 === 1) {
                            text += "\n";
                        }
                    }
                }
            }
            text += "};\n\n";

            // Add palette here
            text += palette.getText();

        } else {
            window.alert("Error during conversion: Mode " + mode.toString + " not found");
            return;
        }

        // Save text to file
        let blob = new Blob([text], {type: "text/h;charset=utf-8"});
        fileSaver.saveAs(blob, filename + ".h");

    } catch (e) {
        window.alert("Error during conversion: " + e.message);
    }
}

/**
 * Given an RGB color (0-255 for each value), return an
 * integer from 0 to 32,767 representing GBA-formatted color.
 */
function rgbToGba(red, green, blue) {
    if (red < 0 || red > 255 ||
        green < 0 || green > 255 ||
        blue < 0 || blue > 255) {
        throw new RangeError("RGB values out of range");
    }
    let r = red >> 3;
    let g = green >> 3;
    let b = blue >> 3;
    return r + (g * 32) + (b * 1024);
}