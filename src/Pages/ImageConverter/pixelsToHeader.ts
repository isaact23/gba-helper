import Palette from "./palette.ts";
import fileSaver from "file-saver";
import getPixels from "image-pixels";


// TODO: Clean this code up for real; add way to convert multiple files at once
/**
 * Given an array of the RGB values of an image and a conversion mode,
 * generate a header file formatted for GBA.
 */
export async function convert(image: string, mode: string, filename: string) {
  const {data, width, height} = await getPixels(image);
  const getPixel = (x: number, y: number, c: number) => {
    return data[(y * 8) + (x * 4) + c];
  }

  try {
    // Store output text
    let text = "// Generated by gbahelper.com\n";

    // Perform mode-dependent conversion
    if (mode === "bitmap32768") {
      text += "// Conversion mode: Bitmap without Palette (32,768 colors)\n\n";
      text += "#include <stdint.h>\n\n"
      text += "#define " + filename + "_width " + width + "\n";
      text += "#define " + filename + "_height " + height + "\n\n";
      text += "const uint16_t " + filename + "_data [] = {\n";

      // Iterate through all pixels, left to right, then top to bottom
      for (let y = 0; y < height; y++) {
        text += "\t";
        for (let x = 0; x < width; x++) {
          // Convert RGB to GBA-formatted hex
          let r = getPixel(x, y, 0);
          let g = getPixel(x, y, 1);
          let b = getPixel(x, y, 2);
          let color = rgbToGba(r, g, b);
          let hex = "0x" + color.toString(16).padStart(4, "0");
          text += hex + ", ";
        }
        text += "\n";
      }
      text += "};\n";

    } else if (mode === "bitmap256") {
      // Create palette to store colors
      let palette = new Palette();

      text += "// Conversion mode: Bitmap with Palette (256 colors)\n\n";
      text += "#include <stdint.h>\n\n"
      text += "#define " + filename + "_width " + width + "\n";
      text += "#define " + filename + "_height " + height + "\n\n";
      text += "const uint8_t " + filename + "_data [] = {\n";

      // Iterate through all pixels, left to right, then top to bottom
      for (let y = 0; y < height; y++) {
        text += "\t";
        for (let x = 0; x < width; x++) {
          // Convert RGB to GBA-formatted hex
          let r = getPixel(x, y, 0);
          let g = getPixel(x, y, 1);
          let b = getPixel(x, y, 2);
          let color = rgbToGba(r, g, b);
          // Add color to palette
          let index = palette.addColor(color);
          if (index == null) {
            window.alert("Error during conversion: Color palette exceeds 256 colors - try reducing color" +
              "count and submit again.");
            return;
          }
          let hex = "0x" + index.toString(16).padStart(2, "0");
          text += hex + ", ";
        }
        text += "\n";
      }
      text += "};\n\n";

      // Add palette here
      text += palette.getText();

    } else if (mode === "tiles") {
      // Create palette to store colors
      let palette = new Palette();

      // Determine number of 8x8 tiles across/down
      let tileCountX = Math.ceil(width / 8);
      let tileCountY = Math.ceil(height / 8);

      text += "// Conversion mode: Tiles (8x8 squares, 256-color palette)\n\n";
      text += "#include <stdint.h>\n\n"
      text += "#define " + filename + "_tileCountX " + tileCountX + "\n";
      text += "#define " + filename + "_tileCountY " + tileCountY + "\n\n";
      text += "const uint8_t " + filename + "_data [] = {\n";

      // Iterate through tiles
      for (let tileY = 0; tileY < tileCountY; tileY++) {
        for (let tileX = 0; tileX < tileCountX; tileX++) {
          // Iterate through pixels within each tile
          for (let localY = 0; localY < 8; localY++) {
            if (localY % 2 === 0) {
              text += "\t";
            }
            let y = (tileY * 8) + localY;
            for (let localX = 0; localX < 8; localX++) {
              let x = (tileX * 8) + localX;
              // If out of bounds, use first color in palette.
              if (x >= width || y >= height) {
                text += "0x00, ";
              } else {
                // Convert RGB to GBA-formatted hex
                let r = getPixel(x, y, 0);
                let g = getPixel(x, y, 1);
                let b = getPixel(x, y, 2);
                let color = rgbToGba(r, g, b);
                // Add color to palette
                let index = palette.addColor(color);
                if (index == null) {
                  window.alert("Error during conversion: Color palette exceeds 256 colors - try reducing" +
                    "color count and submit again.");
                  return;
                }
                let hex = "0x" + index.toString(16).padStart(2, "0");
                text += hex + ", ";
              }
            }
            // Add line breaks every 16 entries
            if (localY % 2 === 1) {
              text += "\n";
            }
          }
        }
      }
      text += "};\n\n";

      // Add palette here
      text += palette.getText();

    } else {
      window.alert("Error during conversion: Mode " + mode.toString() + " not found");
      return;
    }

    // Save text to file
    let blob = new Blob([text], {type: "text/h;charset=utf-8"});
    fileSaver.saveAs(blob, filename + ".h");

  } catch {
    window.alert("Unknown error during conversation");
  }
}

/**
 * Given an RGB color (0-255 for each value), return an
 * integer from 0 to 32,767 representing GBA-formatted color.
 */
function rgbToGba(red: number, green: number, blue: number) {
  if (red < 0 || red > 255 ||
    green < 0 || green > 255 ||
    blue < 0 || blue > 255) {
    throw new RangeError("RGB values out of range");
  }
  let r = red >> 3;
  let g = green >> 3;
  let b = blue >> 3;
  return r + (g * 32) + (b * 1024);
}